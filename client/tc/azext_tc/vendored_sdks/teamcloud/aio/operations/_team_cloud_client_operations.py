# coding=utf-8
# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.
# Code generated by Microsoft (R) AutoRest Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# --------------------------------------------------------------------------
from typing import Any, Callable, Dict, Generic, Optional, TypeVar, Union
import warnings

from azure.core.exceptions import ClientAuthenticationError, HttpResponseError, ResourceExistsError, ResourceNotFoundError, map_error
from azure.core.pipeline import PipelineResponse
from azure.core.pipeline.transport import AsyncHttpResponse, HttpRequest

from ... import models

T = TypeVar('T')
ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]

class TeamCloudClientOperationsMixin:

    async def get_projects(
        self,
        **kwargs
    ) -> Optional[Union["models.ProjectListDataResult", "models.ErrorResult"]]:
        """Gets all Projects.

        Gets all Projects.

        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: ProjectListDataResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.ProjectListDataResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union["models.ProjectListDataResult", "models.ErrorResult"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_projects.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('ProjectListDataResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_projects.metadata = {'url': '/api/projects'}  # type: ignore

    async def create_project(
        self,
        body: Optional["models.ProjectDefinition"] = None,
        **kwargs
    ) -> Optional[Union["models.StatusResult", "models.ErrorResult"]]:
        """Creates a new Project.

        Creates a new Project.

        :param body:
        :type body: ~teamcloud.models.ProjectDefinition
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: StatusResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.StatusResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union["models.StatusResult", "models.ErrorResult"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_project.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        if body is not None:
            body_content = self._serialize.body(body, 'ProjectDefinition')
        else:
            body_content = None
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [202, 400, 401, 403, 409]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 202:
            deserialized = self._deserialize('StatusResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 409:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_project.metadata = {'url': '/api/projects'}  # type: ignore

    async def get_project_by_name_or_id(
        self,
        project_name_or_id: str,
        **kwargs
    ) -> Optional[Union["models.ProjectDataResult", "models.ErrorResult"]]:
        """Gets a Project by Name or ID.

        Gets a Project by Name or ID.

        :param project_name_or_id:
        :type project_name_or_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: ProjectDataResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.ProjectDataResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union["models.ProjectDataResult", "models.ErrorResult"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_project_by_name_or_id.metadata['url']  # type: ignore
        path_format_arguments = {
            'projectNameOrId': self._serialize.url("project_name_or_id", project_name_or_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('ProjectDataResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_project_by_name_or_id.metadata = {'url': '/api/projects/{projectNameOrId}'}  # type: ignore

    async def delete_project(
        self,
        project_name_or_id: str,
        **kwargs
    ) -> Optional[Union["models.StatusResult", "models.ErrorResult"]]:
        """Deletes a Project.

        Deletes a Project.

        :param project_name_or_id:
        :type project_name_or_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: StatusResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.StatusResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union["models.StatusResult", "models.ErrorResult"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.delete_project.metadata['url']  # type: ignore
        path_format_arguments = {
            'projectNameOrId': self._serialize.url("project_name_or_id", project_name_or_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [202, 400, 401, 403, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 202:
            deserialized = self._deserialize('StatusResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    delete_project.metadata = {'url': '/api/projects/{projectNameOrId}'}  # type: ignore

    async def get_project_identity(
        self,
        project_id: str,
        **kwargs
    ) -> Optional[Union["models.ProjectIdentityDataResult", "models.ErrorResult"]]:
        """Gets the ProjectIdentity for a Project.

        Gets the ProjectIdentity for a Project.

        :param project_id:
        :type project_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: ProjectIdentityDataResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.ProjectIdentityDataResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union["models.ProjectIdentityDataResult", "models.ErrorResult"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_project_identity.metadata['url']  # type: ignore
        path_format_arguments = {
            'projectId': self._serialize.url("project_id", project_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('ProjectIdentityDataResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_project_identity.metadata = {'url': '/api/projects/{projectId}/identity'}  # type: ignore

    async def get_project_links(
        self,
        project_id: str,
        **kwargs
    ) -> Optional[Union["models.StringDictionaryDataResult", "models.ErrorResult"]]:
        """Gets all Links for a Project.

        Gets all Links for a Project.

        :param project_id:
        :type project_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: StringDictionaryDataResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.StringDictionaryDataResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union["models.StringDictionaryDataResult", "models.ErrorResult"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_project_links.metadata['url']  # type: ignore
        path_format_arguments = {
            'projectId': self._serialize.url("project_id", project_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('StringDictionaryDataResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_project_links.metadata = {'url': '/api/projects/{projectId}/links'}  # type: ignore

    async def create_project_link(
        self,
        project_id: str,
        body: Optional["models.ProjectLink"] = None,
        **kwargs
    ) -> Optional[Union["models.ProjectLinkDataResult", "models.StatusResult", "models.ErrorResult"]]:
        """Creates a new Project Link.

        Creates a new Project Link.

        :param project_id:
        :type project_id: str
        :param body:
        :type body: ~teamcloud.models.ProjectLink
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: ProjectLinkDataResult or StatusResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.ProjectLinkDataResult or ~teamcloud.models.StatusResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union["models.ProjectLinkDataResult", "models.StatusResult", "models.ErrorResult"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_project_link.metadata['url']  # type: ignore
        path_format_arguments = {
            'projectId': self._serialize.url("project_id", project_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        if body is not None:
            body_content = self._serialize.body(body, 'ProjectLink')
        else:
            body_content = None
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201, 202, 400, 401, 403, 404, 409]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 201:
            deserialized = self._deserialize('ProjectLinkDataResult', pipeline_response)

        if response.status_code == 202:
            deserialized = self._deserialize('StatusResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 409:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_project_link.metadata = {'url': '/api/projects/{projectId}/links'}  # type: ignore

    async def get_project_link_by_key(
        self,
        link_id: str,
        project_id: str,
        **kwargs
    ) -> Optional[Union["models.StringDictionaryDataResult", "models.ErrorResult"]]:
        """Gets a Project Link by Key.

        Gets a Project Link by Key.

        :param link_id:
        :type link_id: str
        :param project_id:
        :type project_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: StringDictionaryDataResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.StringDictionaryDataResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union["models.StringDictionaryDataResult", "models.ErrorResult"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_project_link_by_key.metadata['url']  # type: ignore
        path_format_arguments = {
            'linkId': self._serialize.url("link_id", link_id, 'str'),
            'projectId': self._serialize.url("project_id", project_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('StringDictionaryDataResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_project_link_by_key.metadata = {'url': '/api/projects/{projectId}/links/{linkId}'}  # type: ignore

    async def update_project_link(
        self,
        link_id: str,
        project_id: str,
        body: Optional["models.ProjectLink"] = None,
        **kwargs
    ) -> Optional[Union["models.ProjectLinkDataResult", "models.StatusResult", "models.ErrorResult"]]:
        """Updates an existing Project Link.

        Updates an existing Project Link.

        :param link_id:
        :type link_id: str
        :param project_id:
        :type project_id: str
        :param body:
        :type body: ~teamcloud.models.ProjectLink
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: ProjectLinkDataResult or StatusResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.ProjectLinkDataResult or ~teamcloud.models.StatusResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union["models.ProjectLinkDataResult", "models.StatusResult", "models.ErrorResult"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.update_project_link.metadata['url']  # type: ignore
        path_format_arguments = {
            'linkId': self._serialize.url("link_id", link_id, 'str'),
            'projectId': self._serialize.url("project_id", project_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        if body is not None:
            body_content = self._serialize.body(body, 'ProjectLink')
        else:
            body_content = None
        body_content_kwargs['content'] = body_content
        request = self._client.put(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 202, 400, 401, 403, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('ProjectLinkDataResult', pipeline_response)

        if response.status_code == 202:
            deserialized = self._deserialize('StatusResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    update_project_link.metadata = {'url': '/api/projects/{projectId}/links/{linkId}'}  # type: ignore

    async def delete_project_link(
        self,
        link_id: str,
        project_id: str,
        **kwargs
    ) -> Optional[Union["models.StatusResult", "models.ProjectLinkDataResult", "models.ErrorResult"]]:
        """Deletes an existing Project Link.

        Deletes an existing Project Link.

        :param link_id:
        :type link_id: str
        :param project_id:
        :type project_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: StatusResult or ProjectLinkDataResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.StatusResult or ~teamcloud.models.ProjectLinkDataResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union["models.StatusResult", "models.ProjectLinkDataResult", "models.ErrorResult"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.delete_project_link.metadata['url']  # type: ignore
        path_format_arguments = {
            'linkId': self._serialize.url("link_id", link_id, 'str'),
            'projectId': self._serialize.url("project_id", project_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [202, 204, 400, 401, 403, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 202:
            deserialized = self._deserialize('StatusResult', pipeline_response)

        if response.status_code == 204:
            deserialized = self._deserialize('ProjectLinkDataResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    delete_project_link.metadata = {'url': '/api/projects/{projectId}/links/{linkId}'}  # type: ignore

    async def get_project_provider_data(
        self,
        project_id: str,
        provider_id: str,
        include_shared: Optional[bool] = None,
        **kwargs
    ) -> Optional[Union["models.ProviderDataResult", "models.ErrorResult"]]:
        """Gets the ProviderData items for a Project.

        Gets the ProviderData items for a Project.

        :param project_id:
        :type project_id: str
        :param provider_id:
        :type provider_id: str
        :param include_shared:
        :type include_shared: bool
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: ProviderDataResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.ProviderDataResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union["models.ProviderDataResult", "models.ErrorResult"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_project_provider_data.metadata['url']  # type: ignore
        path_format_arguments = {
            'projectId': self._serialize.url("project_id", project_id, 'str'),
            'providerId': self._serialize.url("provider_id", provider_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if include_shared is not None:
            query_parameters['includeShared'] = self._serialize.query("include_shared", include_shared, 'bool')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('ProviderDataResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_project_provider_data.metadata = {'url': '/api/projects/{projectId}/providers/{providerId}/data'}  # type: ignore

    async def create_project_provider_data(
        self,
        project_id: str,
        provider_id: str,
        body: Optional["models.ProviderData"] = None,
        **kwargs
    ) -> Optional[Union["models.ProviderDataResult", "models.ErrorResult"]]:
        """Creates a new ProviderData.

        Creates a new ProviderData.

        :param project_id:
        :type project_id: str
        :param provider_id:
        :type provider_id: str
        :param body:
        :type body: ~teamcloud.models.ProviderData
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: ProviderDataResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.ProviderDataResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union["models.ProviderDataResult", "models.ErrorResult"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_project_provider_data.metadata['url']  # type: ignore
        path_format_arguments = {
            'projectId': self._serialize.url("project_id", project_id, 'str'),
            'providerId': self._serialize.url("provider_id", provider_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        if body is not None:
            body_content = self._serialize.body(body, 'ProviderData')
        else:
            body_content = None
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201, 400, 401, 403, 404, 409]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 201:
            deserialized = self._deserialize('ProviderDataResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 409:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_project_provider_data.metadata = {'url': '/api/projects/{projectId}/providers/{providerId}/data'}  # type: ignore

    async def get_project_provider_data_by_id(
        self,
        provider_data_id: str,
        project_id: str,
        provider_id: str,
        **kwargs
    ) -> Optional[Union["models.ProviderDataResult", "models.ErrorResult"]]:
        """Gets a ProviderData for a Project by ID.

        Gets a ProviderData for a Project by ID.

        :param provider_data_id:
        :type provider_data_id: str
        :param project_id:
        :type project_id: str
        :param provider_id:
        :type provider_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: ProviderDataResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.ProviderDataResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union["models.ProviderDataResult", "models.ErrorResult"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_project_provider_data_by_id.metadata['url']  # type: ignore
        path_format_arguments = {
            'providerDataId': self._serialize.url("provider_data_id", provider_data_id, 'str'),
            'projectId': self._serialize.url("project_id", project_id, 'str'),
            'providerId': self._serialize.url("provider_id", provider_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('ProviderDataResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_project_provider_data_by_id.metadata = {'url': '/api/projects/{projectId}/providers/{providerId}/data/{providerDataId}'}  # type: ignore

    async def update_project_provider_data(
        self,
        provider_data_id: str,
        project_id: str,
        provider_id: str,
        body: Optional["models.ProviderData"] = None,
        **kwargs
    ) -> Optional[Union["models.ProviderDataResult", "models.ErrorResult"]]:
        """Updates an existing ProviderData.

        Updates an existing ProviderData.

        :param provider_data_id:
        :type provider_data_id: str
        :param project_id:
        :type project_id: str
        :param provider_id:
        :type provider_id: str
        :param body:
        :type body: ~teamcloud.models.ProviderData
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: ProviderDataResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.ProviderDataResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union["models.ProviderDataResult", "models.ErrorResult"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.update_project_provider_data.metadata['url']  # type: ignore
        path_format_arguments = {
            'providerDataId': self._serialize.url("provider_data_id", provider_data_id, 'str'),
            'projectId': self._serialize.url("project_id", project_id, 'str'),
            'providerId': self._serialize.url("provider_id", provider_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        if body is not None:
            body_content = self._serialize.body(body, 'ProviderData')
        else:
            body_content = None
        body_content_kwargs['content'] = body_content
        request = self._client.put(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('ProviderDataResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    update_project_provider_data.metadata = {'url': '/api/projects/{projectId}/providers/{providerId}/data/{providerDataId}'}  # type: ignore

    async def delete_project_provider_data(
        self,
        provider_data_id: str,
        project_id: str,
        provider_id: str,
        **kwargs
    ) -> Optional[Union["models.ProviderDataResult", "models.ErrorResult"]]:
        """Deletes a ProviderData.

        Deletes a ProviderData.

        :param provider_data_id:
        :type provider_data_id: str
        :param project_id:
        :type project_id: str
        :param provider_id:
        :type provider_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: ProviderDataResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.ProviderDataResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union["models.ProviderDataResult", "models.ErrorResult"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.delete_project_provider_data.metadata['url']  # type: ignore
        path_format_arguments = {
            'providerDataId': self._serialize.url("provider_data_id", provider_data_id, 'str'),
            'projectId': self._serialize.url("project_id", project_id, 'str'),
            'providerId': self._serialize.url("provider_id", provider_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204, 400, 401, 403, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 204:
            deserialized = self._deserialize('ProviderDataResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    delete_project_provider_data.metadata = {'url': '/api/projects/{projectId}/providers/{providerId}/data/{providerDataId}'}  # type: ignore

    async def get_project_tags(
        self,
        project_id: str,
        **kwargs
    ) -> Optional[Union["models.StringDictionaryDataResult", "models.ErrorResult"]]:
        """Gets all Tags for a Project.

        Gets all Tags for a Project.

        :param project_id:
        :type project_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: StringDictionaryDataResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.StringDictionaryDataResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union["models.StringDictionaryDataResult", "models.ErrorResult"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_project_tags.metadata['url']  # type: ignore
        path_format_arguments = {
            'projectId': self._serialize.url("project_id", project_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('StringDictionaryDataResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_project_tags.metadata = {'url': '/api/projects/{projectId}/tags'}  # type: ignore

    async def create_project_tag(
        self,
        project_id: str,
        body: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> Optional[Union["models.StatusResult", "models.ErrorResult"]]:
        """Creates a new Project Tag.

        Creates a new Project Tag.

        :param project_id:
        :type project_id: str
        :param body:
        :type body: dict[str, str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: StatusResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.StatusResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union["models.StatusResult", "models.ErrorResult"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_project_tag.metadata['url']  # type: ignore
        path_format_arguments = {
            'projectId': self._serialize.url("project_id", project_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        if body is not None:
            body_content = self._serialize.body(body, '{str}')
        else:
            body_content = None
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [202, 400, 401, 403, 404, 409]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 202:
            deserialized = self._deserialize('StatusResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 409:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_project_tag.metadata = {'url': '/api/projects/{projectId}/tags'}  # type: ignore

    async def update_project_tag(
        self,
        project_id: str,
        body: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> Optional[Union["models.StatusResult", "models.ErrorResult"]]:
        """Updates an existing Project Tag.

        Updates an existing Project Tag.

        :param project_id:
        :type project_id: str
        :param body:
        :type body: dict[str, str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: StatusResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.StatusResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union["models.StatusResult", "models.ErrorResult"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.update_project_tag.metadata['url']  # type: ignore
        path_format_arguments = {
            'projectId': self._serialize.url("project_id", project_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        if body is not None:
            body_content = self._serialize.body(body, '{str}')
        else:
            body_content = None
        body_content_kwargs['content'] = body_content
        request = self._client.put(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [202, 400, 401, 403, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 202:
            deserialized = self._deserialize('StatusResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    update_project_tag.metadata = {'url': '/api/projects/{projectId}/tags'}  # type: ignore

    async def get_project_tag_by_key(
        self,
        tag_key: str,
        project_id: str,
        **kwargs
    ) -> Optional[Union["models.StringDictionaryDataResult", "models.ErrorResult"]]:
        """Gets a Project Tag by Key.

        Gets a Project Tag by Key.

        :param tag_key:
        :type tag_key: str
        :param project_id:
        :type project_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: StringDictionaryDataResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.StringDictionaryDataResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union["models.StringDictionaryDataResult", "models.ErrorResult"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_project_tag_by_key.metadata['url']  # type: ignore
        path_format_arguments = {
            'tagKey': self._serialize.url("tag_key", tag_key, 'str'),
            'projectId': self._serialize.url("project_id", project_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('StringDictionaryDataResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_project_tag_by_key.metadata = {'url': '/api/projects/{projectId}/tags/{tagKey}'}  # type: ignore

    async def delete_project_tag(
        self,
        tag_key: str,
        project_id: str,
        **kwargs
    ) -> Optional[Union["models.StatusResult", "models.ErrorResult"]]:
        """Deletes an existing Project Tag.

        Deletes an existing Project Tag.

        :param tag_key:
        :type tag_key: str
        :param project_id:
        :type project_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: StatusResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.StatusResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union["models.StatusResult", "models.ErrorResult"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.delete_project_tag.metadata['url']  # type: ignore
        path_format_arguments = {
            'tagKey': self._serialize.url("tag_key", tag_key, 'str'),
            'projectId': self._serialize.url("project_id", project_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [202, 400, 401, 403, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 202:
            deserialized = self._deserialize('StatusResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    delete_project_tag.metadata = {'url': '/api/projects/{projectId}/tags/{tagKey}'}  # type: ignore

    async def get_project_types(
        self,
        **kwargs
    ) -> Optional[Union["models.ProjectTypeListDataResult", "models.ErrorResult"]]:
        """Gets all Project Types.

        Gets all Project Types.

        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: ProjectTypeListDataResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.ProjectTypeListDataResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union["models.ProjectTypeListDataResult", "models.ErrorResult"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_project_types.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('ProjectTypeListDataResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_project_types.metadata = {'url': '/api/projectTypes'}  # type: ignore

    async def create_project_type(
        self,
        body: Optional["models.ProjectType"] = None,
        **kwargs
    ) -> Optional[Union["models.ProjectTypeDataResult", "models.ErrorResult"]]:
        """Creates a new Project Type.

        Creates a new Project Type.

        :param body:
        :type body: ~teamcloud.models.ProjectType
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: ProjectTypeDataResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.ProjectTypeDataResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union["models.ProjectTypeDataResult", "models.ErrorResult"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_project_type.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        if body is not None:
            body_content = self._serialize.body(body, 'ProjectType')
        else:
            body_content = None
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201, 400, 401, 403, 409]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 201:
            deserialized = self._deserialize('ProjectTypeDataResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 409:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_project_type.metadata = {'url': '/api/projectTypes'}  # type: ignore

    async def get_project_type_by_id(
        self,
        project_type_id: str,
        **kwargs
    ) -> Optional[Union["models.ProjectTypeDataResult", "models.ErrorResult"]]:
        """Gets a Project Type by ID.

        Gets a Project Type by ID.

        :param project_type_id:
        :type project_type_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: ProjectTypeDataResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.ProjectTypeDataResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union["models.ProjectTypeDataResult", "models.ErrorResult"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_project_type_by_id.metadata['url']  # type: ignore
        path_format_arguments = {
            'projectTypeId': self._serialize.url("project_type_id", project_type_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('ProjectTypeDataResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_project_type_by_id.metadata = {'url': '/api/projectTypes/{projectTypeId}'}  # type: ignore

    async def update_project_type(
        self,
        project_type_id: str,
        body: Optional["models.ProjectType"] = None,
        **kwargs
    ) -> Optional[Union["models.ProjectTypeDataResult", "models.ErrorResult"]]:
        """Updates an existing Project Type.

        Updates an existing Project Type.

        :param project_type_id:
        :type project_type_id: str
        :param body:
        :type body: ~teamcloud.models.ProjectType
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: ProjectTypeDataResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.ProjectTypeDataResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union["models.ProjectTypeDataResult", "models.ErrorResult"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.update_project_type.metadata['url']  # type: ignore
        path_format_arguments = {
            'projectTypeId': self._serialize.url("project_type_id", project_type_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        if body is not None:
            body_content = self._serialize.body(body, 'ProjectType')
        else:
            body_content = None
        body_content_kwargs['content'] = body_content
        request = self._client.put(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('ProjectTypeDataResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    update_project_type.metadata = {'url': '/api/projectTypes/{projectTypeId}'}  # type: ignore

    async def delete_project_type(
        self,
        project_type_id: str,
        **kwargs
    ) -> Optional[Union["models.ProjectTypeDataResult", "models.ErrorResult"]]:
        """Deletes a Project Type.

        Deletes a Project Type.

        :param project_type_id:
        :type project_type_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: ProjectTypeDataResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.ProjectTypeDataResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union["models.ProjectTypeDataResult", "models.ErrorResult"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.delete_project_type.metadata['url']  # type: ignore
        path_format_arguments = {
            'projectTypeId': self._serialize.url("project_type_id", project_type_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204, 400, 401, 403, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 204:
            deserialized = self._deserialize('ProjectTypeDataResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    delete_project_type.metadata = {'url': '/api/projectTypes/{projectTypeId}'}  # type: ignore

    async def get_project_users(
        self,
        project_id: str,
        **kwargs
    ) -> Optional[Union["models.UserListDataResult", "models.ErrorResult"]]:
        """Gets all Users for a Project.

        Gets all Users for a Project.

        :param project_id:
        :type project_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: UserListDataResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.UserListDataResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union["models.UserListDataResult", "models.ErrorResult"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_project_users.metadata['url']  # type: ignore
        path_format_arguments = {
            'projectId': self._serialize.url("project_id", project_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('UserListDataResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_project_users.metadata = {'url': '/api/projects/{projectId}/users'}  # type: ignore

    async def create_project_user(
        self,
        project_id: str,
        body: Optional["models.UserDefinition"] = None,
        **kwargs
    ) -> Optional[Union["models.StatusResult", "models.ErrorResult"]]:
        """Creates a new Project User.

        Creates a new Project User.

        :param project_id:
        :type project_id: str
        :param body:
        :type body: ~teamcloud.models.UserDefinition
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: StatusResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.StatusResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union["models.StatusResult", "models.ErrorResult"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_project_user.metadata['url']  # type: ignore
        path_format_arguments = {
            'projectId': self._serialize.url("project_id", project_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        if body is not None:
            body_content = self._serialize.body(body, 'UserDefinition')
        else:
            body_content = None
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [202, 400, 401, 403, 404, 409]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 202:
            deserialized = self._deserialize('StatusResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 409:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_project_user.metadata = {'url': '/api/projects/{projectId}/users'}  # type: ignore

    async def get_project_user_by_name_or_id(
        self,
        user_name_or_id: str,
        project_id: str,
        **kwargs
    ) -> Optional[Union["models.UserDataResult", "models.ErrorResult"]]:
        """Gets a Project User by ID or email address.

        Gets a Project User by ID or email address.

        :param user_name_or_id:
        :type user_name_or_id: str
        :param project_id:
        :type project_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: UserDataResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.UserDataResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union["models.UserDataResult", "models.ErrorResult"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_project_user_by_name_or_id.metadata['url']  # type: ignore
        path_format_arguments = {
            'userNameOrId': self._serialize.url("user_name_or_id", user_name_or_id, 'str'),
            'projectId': self._serialize.url("project_id", project_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('UserDataResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_project_user_by_name_or_id.metadata = {'url': '/api/projects/{projectId}/users/{userNameOrId}'}  # type: ignore

    async def update_project_user(
        self,
        user_name_or_id: str,
        project_id: str,
        body: Optional["models.User"] = None,
        **kwargs
    ) -> Optional[Union["models.StatusResult", "models.ErrorResult"]]:
        """Updates an existing Project User.

        Updates an existing Project User.

        :param user_name_or_id:
        :type user_name_or_id: str
        :param project_id:
        :type project_id: str
        :param body:
        :type body: ~teamcloud.models.User
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: StatusResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.StatusResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union["models.StatusResult", "models.ErrorResult"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.update_project_user.metadata['url']  # type: ignore
        path_format_arguments = {
            'userNameOrId': self._serialize.url("user_name_or_id", user_name_or_id, 'str'),
            'projectId': self._serialize.url("project_id", project_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        if body is not None:
            body_content = self._serialize.body(body, 'User')
        else:
            body_content = None
        body_content_kwargs['content'] = body_content
        request = self._client.put(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [202, 400, 401, 403, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 202:
            deserialized = self._deserialize('StatusResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    update_project_user.metadata = {'url': '/api/projects/{projectId}/users/{userNameOrId}'}  # type: ignore

    async def delete_project_user(
        self,
        user_name_or_id: str,
        project_id: str,
        **kwargs
    ) -> Optional[Union["models.StatusResult", "models.ErrorResult"]]:
        """Deletes an existing Project User.

        Deletes an existing Project User.

        :param user_name_or_id:
        :type user_name_or_id: str
        :param project_id:
        :type project_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: StatusResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.StatusResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union["models.StatusResult", "models.ErrorResult"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.delete_project_user.metadata['url']  # type: ignore
        path_format_arguments = {
            'userNameOrId': self._serialize.url("user_name_or_id", user_name_or_id, 'str'),
            'projectId': self._serialize.url("project_id", project_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [202, 400, 401, 403, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 202:
            deserialized = self._deserialize('StatusResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    delete_project_user.metadata = {'url': '/api/projects/{projectId}/users/{userNameOrId}'}  # type: ignore

    async def get_project_user_me(
        self,
        project_id: str,
        **kwargs
    ) -> Optional[Union["models.UserDataResult", "models.ErrorResult"]]:
        """Gets a Project User for the calling user.

        Gets a Project User for the calling user.

        :param project_id:
        :type project_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: UserDataResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.UserDataResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union["models.UserDataResult", "models.ErrorResult"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_project_user_me.metadata['url']  # type: ignore
        path_format_arguments = {
            'projectId': self._serialize.url("project_id", project_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('UserDataResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_project_user_me.metadata = {'url': '/api/projects/{projectId}/users/me'}  # type: ignore

    async def update_project_user_me(
        self,
        project_id: str,
        body: Optional["models.User"] = None,
        **kwargs
    ) -> Optional[Union["models.StatusResult", "models.ErrorResult"]]:
        """Updates an existing Project User.

        Updates an existing Project User.

        :param project_id:
        :type project_id: str
        :param body:
        :type body: ~teamcloud.models.User
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: StatusResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.StatusResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union["models.StatusResult", "models.ErrorResult"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.update_project_user_me.metadata['url']  # type: ignore
        path_format_arguments = {
            'projectId': self._serialize.url("project_id", project_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        if body is not None:
            body_content = self._serialize.body(body, 'User')
        else:
            body_content = None
        body_content_kwargs['content'] = body_content
        request = self._client.put(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [202, 400, 401, 403, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 202:
            deserialized = self._deserialize('StatusResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    update_project_user_me.metadata = {'url': '/api/projects/{projectId}/users/me'}  # type: ignore

    async def get_provider_data(
        self,
        provider_id: str,
        **kwargs
    ) -> Optional[Union["models.ProviderDataListDataResult", "models.ErrorResult"]]:
        """Gets all ProviderData for a Provider.

        Gets all ProviderData for a Provider.

        :param provider_id:
        :type provider_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: ProviderDataListDataResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.ProviderDataListDataResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union["models.ProviderDataListDataResult", "models.ErrorResult"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_provider_data.metadata['url']  # type: ignore
        path_format_arguments = {
            'providerId': self._serialize.url("provider_id", provider_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('ProviderDataListDataResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_provider_data.metadata = {'url': '/api/providers/{providerId}/data'}  # type: ignore

    async def create_provider_data(
        self,
        provider_id: str,
        body: Optional["models.ProviderData"] = None,
        **kwargs
    ) -> Optional[Union["models.ProviderDataResult", "models.ErrorResult"]]:
        """Creates a new ProviderData item.

        Creates a new ProviderData item.

        :param provider_id:
        :type provider_id: str
        :param body:
        :type body: ~teamcloud.models.ProviderData
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: ProviderDataResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.ProviderDataResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union["models.ProviderDataResult", "models.ErrorResult"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_provider_data.metadata['url']  # type: ignore
        path_format_arguments = {
            'providerId': self._serialize.url("provider_id", provider_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        if body is not None:
            body_content = self._serialize.body(body, 'ProviderData')
        else:
            body_content = None
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201, 400, 401, 403, 404, 409]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 201:
            deserialized = self._deserialize('ProviderDataResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 409:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_provider_data.metadata = {'url': '/api/providers/{providerId}/data'}  # type: ignore

    async def get_provider_data_by_id(
        self,
        provider_data_id: str,
        provider_id: str,
        **kwargs
    ) -> Optional[Union["models.ProviderDataResult", "models.ErrorResult"]]:
        """Gets the ProviderData by ID.

        Gets the ProviderData by ID.

        :param provider_data_id:
        :type provider_data_id: str
        :param provider_id:
        :type provider_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: ProviderDataResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.ProviderDataResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union["models.ProviderDataResult", "models.ErrorResult"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_provider_data_by_id.metadata['url']  # type: ignore
        path_format_arguments = {
            'providerDataId': self._serialize.url("provider_data_id", provider_data_id, 'str'),
            'providerId': self._serialize.url("provider_id", provider_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('ProviderDataResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_provider_data_by_id.metadata = {'url': '/api/providers/{providerId}/data/{providerDataId}'}  # type: ignore

    async def update_provider_data(
        self,
        provider_data_id: str,
        provider_id: str,
        body: Optional["models.ProviderData"] = None,
        **kwargs
    ) -> Optional[Union["models.ProviderDataResult", "models.ErrorResult"]]:
        """Updates an existing ProviderData.

        Updates an existing ProviderData.

        :param provider_data_id:
        :type provider_data_id: str
        :param provider_id:
        :type provider_id: str
        :param body:
        :type body: ~teamcloud.models.ProviderData
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: ProviderDataResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.ProviderDataResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union["models.ProviderDataResult", "models.ErrorResult"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.update_provider_data.metadata['url']  # type: ignore
        path_format_arguments = {
            'providerDataId': self._serialize.url("provider_data_id", provider_data_id, 'str'),
            'providerId': self._serialize.url("provider_id", provider_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        if body is not None:
            body_content = self._serialize.body(body, 'ProviderData')
        else:
            body_content = None
        body_content_kwargs['content'] = body_content
        request = self._client.put(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('ProviderDataResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    update_provider_data.metadata = {'url': '/api/providers/{providerId}/data/{providerDataId}'}  # type: ignore

    async def delete_provider_data(
        self,
        provider_data_id: str,
        provider_id: str,
        **kwargs
    ) -> Optional[Union["models.ProviderDataResult", "models.ErrorResult"]]:
        """Deletes a ProviderData.

        Deletes a ProviderData.

        :param provider_data_id:
        :type provider_data_id: str
        :param provider_id:
        :type provider_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: ProviderDataResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.ProviderDataResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union["models.ProviderDataResult", "models.ErrorResult"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.delete_provider_data.metadata['url']  # type: ignore
        path_format_arguments = {
            'providerDataId': self._serialize.url("provider_data_id", provider_data_id, 'str'),
            'providerId': self._serialize.url("provider_id", provider_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204, 400, 401, 403, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 204:
            deserialized = self._deserialize('ProviderDataResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    delete_provider_data.metadata = {'url': '/api/providers/{providerId}/data/{providerDataId}'}  # type: ignore

    async def get_providers(
        self,
        **kwargs
    ) -> Optional[Union["models.ProviderListDataResult", "models.ErrorResult"]]:
        """Gets all Providers.

        Gets all Providers.

        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: ProviderListDataResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.ProviderListDataResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union["models.ProviderListDataResult", "models.ErrorResult"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_providers.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('ProviderListDataResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_providers.metadata = {'url': '/api/providers'}  # type: ignore

    async def create_provider(
        self,
        body: Optional["models.Provider"] = None,
        **kwargs
    ) -> Optional[Union["models.StatusResult", "models.ErrorResult"]]:
        """Creates a new Provider.

        Creates a new Provider.

        :param body:
        :type body: ~teamcloud.models.Provider
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: StatusResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.StatusResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union["models.StatusResult", "models.ErrorResult"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_provider.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        if body is not None:
            body_content = self._serialize.body(body, 'Provider')
        else:
            body_content = None
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [202, 400, 401, 403, 409]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 202:
            deserialized = self._deserialize('StatusResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 409:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_provider.metadata = {'url': '/api/providers'}  # type: ignore

    async def get_provider_by_id(
        self,
        provider_id: str,
        **kwargs
    ) -> Optional[Union["models.ProviderDataResultAutoGenerated", "models.ErrorResult"]]:
        """Gets a Provider by ID.

        Gets a Provider by ID.

        :param provider_id:
        :type provider_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: ProviderDataResultAutoGenerated or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.ProviderDataResultAutoGenerated or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union["models.ProviderDataResultAutoGenerated", "models.ErrorResult"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_provider_by_id.metadata['url']  # type: ignore
        path_format_arguments = {
            'providerId': self._serialize.url("provider_id", provider_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('ProviderDataResultAutoGenerated', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_provider_by_id.metadata = {'url': '/api/providers/{providerId}'}  # type: ignore

    async def update_provider(
        self,
        provider_id: str,
        body: Optional["models.Provider"] = None,
        **kwargs
    ) -> Optional[Union["models.StatusResult", "models.ErrorResult"]]:
        """Updates an existing Provider.

        Updates an existing Provider.

        :param provider_id:
        :type provider_id: str
        :param body:
        :type body: ~teamcloud.models.Provider
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: StatusResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.StatusResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union["models.StatusResult", "models.ErrorResult"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.update_provider.metadata['url']  # type: ignore
        path_format_arguments = {
            'providerId': self._serialize.url("provider_id", provider_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        if body is not None:
            body_content = self._serialize.body(body, 'Provider')
        else:
            body_content = None
        body_content_kwargs['content'] = body_content
        request = self._client.put(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [202, 400, 401, 403, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 202:
            deserialized = self._deserialize('StatusResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    update_provider.metadata = {'url': '/api/providers/{providerId}'}  # type: ignore

    async def delete_provider(
        self,
        provider_id: str,
        **kwargs
    ) -> Optional[Union["models.StatusResult", "models.ErrorResult"]]:
        """Deletes an existing Provider.

        Deletes an existing Provider.

        :param provider_id:
        :type provider_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: StatusResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.StatusResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union["models.StatusResult", "models.ErrorResult"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.delete_provider.metadata['url']  # type: ignore
        path_format_arguments = {
            'providerId': self._serialize.url("provider_id", provider_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [202, 400, 401, 403, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 202:
            deserialized = self._deserialize('StatusResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    delete_provider.metadata = {'url': '/api/providers/{providerId}'}  # type: ignore

    async def get_status(
        self,
        tracking_id: str,
        **kwargs
    ) -> Optional[Union["models.StatusResult", "models.ErrorResult"]]:
        """Gets the status of a long-running operation.

        Gets the status of a long-running operation.

        :param tracking_id:
        :type tracking_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: StatusResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.StatusResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union["models.StatusResult", "models.ErrorResult"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_status.metadata['url']  # type: ignore
        path_format_arguments = {
            'trackingId': self._serialize.url("tracking_id", tracking_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 202, 302, 400, 401, 403, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('StatusResult', pipeline_response)

        if response.status_code == 202:
            deserialized = self._deserialize('StatusResult', pipeline_response)

        if response.status_code == 302:
            deserialized = self._deserialize('StatusResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_status.metadata = {'url': '/api/status/{trackingId}'}  # type: ignore

    async def get_project_status(
        self,
        project_id: str,
        tracking_id: str,
        **kwargs
    ) -> Optional[Union["models.StatusResult", "models.ErrorResult"]]:
        """Gets the status of a long-running operation.

        Gets the status of a long-running operation.

        :param project_id:
        :type project_id: str
        :param tracking_id:
        :type tracking_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: StatusResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.StatusResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union["models.StatusResult", "models.ErrorResult"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_project_status.metadata['url']  # type: ignore
        path_format_arguments = {
            'projectId': self._serialize.url("project_id", project_id, 'str'),
            'trackingId': self._serialize.url("tracking_id", tracking_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 202, 302, 400, 401, 403, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('StatusResult', pipeline_response)

        if response.status_code == 202:
            deserialized = self._deserialize('StatusResult', pipeline_response)

        if response.status_code == 302:
            deserialized = self._deserialize('StatusResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_project_status.metadata = {'url': '/api/projects/{projectId}/status/{trackingId}'}  # type: ignore

    async def create_team_cloud_admin_user(
        self,
        body: Optional["models.UserDefinition"] = None,
        **kwargs
    ) -> Optional[Union["models.StatusResult", "models.ErrorResult"]]:
        """Creates a new TeamCloud User as an Admin.

        Creates a new TeamCloud User as an Admin.

        :param body:
        :type body: ~teamcloud.models.UserDefinition
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: StatusResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.StatusResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union["models.StatusResult", "models.ErrorResult"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json, text/json"

        # Construct URL
        url = self.create_team_cloud_admin_user.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        if body is not None:
            body_content = self._serialize.body(body, 'UserDefinition')
        else:
            body_content = None
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [202, 400, 401, 403, 404, 409]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 202:
            deserialized = self._deserialize('StatusResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 409:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_team_cloud_admin_user.metadata = {'url': '/api/admin/users'}  # type: ignore

    async def get_team_cloud_instance(
        self,
        **kwargs
    ) -> Optional[Union["models.TeamCloudInstanceDataResult", "models.ErrorResult"]]:
        """Gets the TeamCloud instance.

        Gets the TeamCloud instance.

        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: TeamCloudInstanceDataResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.TeamCloudInstanceDataResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union["models.TeamCloudInstanceDataResult", "models.ErrorResult"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json, text/json"

        # Construct URL
        url = self.get_team_cloud_instance.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 401, 403, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('TeamCloudInstanceDataResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_team_cloud_instance.metadata = {'url': '/api/admin/teamCloudInstance'}  # type: ignore

    async def create_team_cloud_instance(
        self,
        body: Optional["models.TeamCloudInstance"] = None,
        **kwargs
    ) -> Optional[Union["models.TeamCloudInstanceDataResult", "models.ErrorResult"]]:
        """Updates the TeamCloud instance.

        Updates the TeamCloud instance.

        :param body:
        :type body: ~teamcloud.models.TeamCloudInstance
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: TeamCloudInstanceDataResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.TeamCloudInstanceDataResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union["models.TeamCloudInstanceDataResult", "models.ErrorResult"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json, text/json"

        # Construct URL
        url = self.create_team_cloud_instance.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        if body is not None:
            body_content = self._serialize.body(body, 'TeamCloudInstance')
        else:
            body_content = None
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201, 400, 401, 403, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 201:
            deserialized = self._deserialize('TeamCloudInstanceDataResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_team_cloud_instance.metadata = {'url': '/api/admin/teamCloudInstance'}  # type: ignore

    async def update_team_cloud_instance(
        self,
        body: Optional["models.TeamCloudInstance"] = None,
        **kwargs
    ) -> Optional[Union["models.TeamCloudInstanceDataResult", "models.ErrorResult"]]:
        """Updates the TeamCloud instance.

        Updates the TeamCloud instance.

        :param body:
        :type body: ~teamcloud.models.TeamCloudInstance
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: TeamCloudInstanceDataResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.TeamCloudInstanceDataResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union["models.TeamCloudInstanceDataResult", "models.ErrorResult"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json, text/json"

        # Construct URL
        url = self.update_team_cloud_instance.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        if body is not None:
            body_content = self._serialize.body(body, 'TeamCloudInstance')
        else:
            body_content = None
        body_content_kwargs['content'] = body_content
        request = self._client.put(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('TeamCloudInstanceDataResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    update_team_cloud_instance.metadata = {'url': '/api/admin/teamCloudInstance'}  # type: ignore

    async def get_team_cloud_tags(
        self,
        **kwargs
    ) -> Optional[Union["models.StringDictionaryDataResult", "models.ErrorResult"]]:
        """Gets all Tags for a TeamCloud Instance.

        Gets all Tags for a TeamCloud Instance.

        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: StringDictionaryDataResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.StringDictionaryDataResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union["models.StringDictionaryDataResult", "models.ErrorResult"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_team_cloud_tags.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('StringDictionaryDataResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_team_cloud_tags.metadata = {'url': '/api/tags'}  # type: ignore

    async def create_team_cloud_tag(
        self,
        body: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> Optional[Union["models.StatusResult", "models.ErrorResult"]]:
        """Creates a new TeamCloud Tag.

        Creates a new TeamCloud Tag.

        :param body:
        :type body: dict[str, str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: StatusResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.StatusResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union["models.StatusResult", "models.ErrorResult"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_team_cloud_tag.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        if body is not None:
            body_content = self._serialize.body(body, '{str}')
        else:
            body_content = None
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [202, 400, 401, 403, 404, 409]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 202:
            deserialized = self._deserialize('StatusResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 409:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_team_cloud_tag.metadata = {'url': '/api/tags'}  # type: ignore

    async def update_team_cloud_tag(
        self,
        body: Optional[Dict[str, str]] = None,
        **kwargs
    ) -> Optional[Union["models.StatusResult", "models.ErrorResult"]]:
        """Updates an existing TeamCloud Tag.

        Updates an existing TeamCloud Tag.

        :param body:
        :type body: dict[str, str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: StatusResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.StatusResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union["models.StatusResult", "models.ErrorResult"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.update_team_cloud_tag.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        if body is not None:
            body_content = self._serialize.body(body, '{str}')
        else:
            body_content = None
        body_content_kwargs['content'] = body_content
        request = self._client.put(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [202, 400, 401, 403, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 202:
            deserialized = self._deserialize('StatusResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    update_team_cloud_tag.metadata = {'url': '/api/tags'}  # type: ignore

    async def get_team_cloud_tag_by_key(
        self,
        tag_key: str,
        **kwargs
    ) -> Optional[Union["models.StringDictionaryDataResult", "models.ErrorResult"]]:
        """Gets a TeamCloud Tag by Key.

        Gets a TeamCloud Tag by Key.

        :param tag_key:
        :type tag_key: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: StringDictionaryDataResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.StringDictionaryDataResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union["models.StringDictionaryDataResult", "models.ErrorResult"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_team_cloud_tag_by_key.metadata['url']  # type: ignore
        path_format_arguments = {
            'tagKey': self._serialize.url("tag_key", tag_key, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('StringDictionaryDataResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_team_cloud_tag_by_key.metadata = {'url': '/api/tags/{tagKey}'}  # type: ignore

    async def delete_team_cloud_tag(
        self,
        tag_key: str,
        **kwargs
    ) -> Optional[Union["models.StatusResult", "models.ErrorResult"]]:
        """Deletes an existing TeamCloud Tag.

        Deletes an existing TeamCloud Tag.

        :param tag_key:
        :type tag_key: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: StatusResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.StatusResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union["models.StatusResult", "models.ErrorResult"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.delete_team_cloud_tag.metadata['url']  # type: ignore
        path_format_arguments = {
            'tagKey': self._serialize.url("tag_key", tag_key, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [202, 400, 401, 403, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 202:
            deserialized = self._deserialize('StatusResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    delete_team_cloud_tag.metadata = {'url': '/api/tags/{tagKey}'}  # type: ignore

    async def get_team_cloud_users(
        self,
        **kwargs
    ) -> Optional[Union["models.UserListDataResult", "models.ErrorResult"]]:
        """Gets all TeamCloud Users.

        Gets all TeamCloud Users.

        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: UserListDataResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.UserListDataResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union["models.UserListDataResult", "models.ErrorResult"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_team_cloud_users.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('UserListDataResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_team_cloud_users.metadata = {'url': '/api/users'}  # type: ignore

    async def create_team_cloud_user(
        self,
        body: Optional["models.UserDefinition"] = None,
        **kwargs
    ) -> Optional[Union["models.StatusResult", "models.ErrorResult"]]:
        """Creates a new TeamCloud User.

        Creates a new TeamCloud User.

        :param body:
        :type body: ~teamcloud.models.UserDefinition
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: StatusResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.StatusResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union["models.StatusResult", "models.ErrorResult"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_team_cloud_user.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        if body is not None:
            body_content = self._serialize.body(body, 'UserDefinition')
        else:
            body_content = None
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [202, 400, 401, 403, 404, 409]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 202:
            deserialized = self._deserialize('StatusResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 409:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_team_cloud_user.metadata = {'url': '/api/users'}  # type: ignore

    async def get_team_cloud_user_by_name_or_id(
        self,
        user_name_or_id: str,
        **kwargs
    ) -> Optional[Union["models.UserDataResult", "models.ErrorResult"]]:
        """Gets a TeamCloud User by ID or email address.

        Gets a TeamCloud User by ID or email address.

        :param user_name_or_id:
        :type user_name_or_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: UserDataResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.UserDataResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union["models.UserDataResult", "models.ErrorResult"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_team_cloud_user_by_name_or_id.metadata['url']  # type: ignore
        path_format_arguments = {
            'userNameOrId': self._serialize.url("user_name_or_id", user_name_or_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('UserDataResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_team_cloud_user_by_name_or_id.metadata = {'url': '/api/users/{userNameOrId}'}  # type: ignore

    async def update_team_cloud_user(
        self,
        user_name_or_id: str,
        body: Optional["models.User"] = None,
        **kwargs
    ) -> Optional[Union["models.StatusResult", "models.ErrorResult"]]:
        """Updates an existing TeamCloud User.

        Updates an existing TeamCloud User.

        :param user_name_or_id:
        :type user_name_or_id: str
        :param body:
        :type body: ~teamcloud.models.User
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: StatusResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.StatusResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union["models.StatusResult", "models.ErrorResult"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.update_team_cloud_user.metadata['url']  # type: ignore
        path_format_arguments = {
            'userNameOrId': self._serialize.url("user_name_or_id", user_name_or_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        if body is not None:
            body_content = self._serialize.body(body, 'User')
        else:
            body_content = None
        body_content_kwargs['content'] = body_content
        request = self._client.put(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [202, 400, 401, 403, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 202:
            deserialized = self._deserialize('StatusResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    update_team_cloud_user.metadata = {'url': '/api/users/{userNameOrId}'}  # type: ignore

    async def delete_team_cloud_user(
        self,
        user_name_or_id: str,
        **kwargs
    ) -> Optional[Union["models.StatusResult", "models.ErrorResult"]]:
        """Deletes an existing TeamCloud User.

        Deletes an existing TeamCloud User.

        :param user_name_or_id:
        :type user_name_or_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: StatusResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.StatusResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union["models.StatusResult", "models.ErrorResult"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.delete_team_cloud_user.metadata['url']  # type: ignore
        path_format_arguments = {
            'userNameOrId': self._serialize.url("user_name_or_id", user_name_or_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [202, 401, 403, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 202:
            deserialized = self._deserialize('StatusResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    delete_team_cloud_user.metadata = {'url': '/api/users/{userNameOrId}'}  # type: ignore

    async def get_team_cloud_user_me(
        self,
        **kwargs
    ) -> Optional[Union["models.UserDataResult", "models.ErrorResult"]]:
        """Gets a TeamCloud User A User matching the current authenticated user.

        Gets a TeamCloud User A User matching the current authenticated user.

        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: UserDataResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.UserDataResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union["models.UserDataResult", "models.ErrorResult"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_team_cloud_user_me.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('UserDataResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_team_cloud_user_me.metadata = {'url': '/api/me'}  # type: ignore

    async def update_team_cloud_user_me(
        self,
        body: Optional["models.User"] = None,
        **kwargs
    ) -> Optional[Union["models.StatusResult", "models.ErrorResult"]]:
        """Updates an existing TeamCloud User.

        Updates an existing TeamCloud User.

        :param body:
        :type body: ~teamcloud.models.User
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: StatusResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.StatusResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union["models.StatusResult", "models.ErrorResult"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.update_team_cloud_user_me.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        if body is not None:
            body_content = self._serialize.body(body, 'User')
        else:
            body_content = None
        body_content_kwargs['content'] = body_content
        request = self._client.put(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [202, 400, 401, 403, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 202:
            deserialized = self._deserialize('StatusResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    update_team_cloud_user_me.metadata = {'url': '/api/me'}  # type: ignore

    async def get_user_projects(
        self,
        user_id: str,
        **kwargs
    ) -> Optional[Union["models.ProjectListDataResult", "models.ErrorResult"]]:
        """Gets all Projects for a User.

        Gets all Projects for a User.

        :param user_id:
        :type user_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: ProjectListDataResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.ProjectListDataResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union["models.ProjectListDataResult", "models.ErrorResult"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_user_projects.metadata['url']  # type: ignore
        path_format_arguments = {
            'userId': self._serialize.url("user_id", user_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('ProjectListDataResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_user_projects.metadata = {'url': '/api/users/{userId}/projects'}  # type: ignore

    async def get_user_projects_me(
        self,
        **kwargs
    ) -> Optional[Union["models.ProjectListDataResult", "models.ErrorResult"]]:
        """Gets all Projects for a User.

        Gets all Projects for a User.

        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: ProjectListDataResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.ProjectListDataResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union["models.ProjectListDataResult", "models.ErrorResult"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_user_projects_me.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('ProjectListDataResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_user_projects_me.metadata = {'url': '/api/me/projects'}  # type: ignore
